<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="description" content="P2P Group Calling" />
        <!-- Facebook Meta Tags -->
        <meta property="og:url" content="https://osho.is-a.dev/p2p.vc/" />
        <meta property="og:type" content="website" />
        <meta property="og:title" content="P2P Group Calling" />
        <meta property="og:description" content="" />
        <meta
            property="og:image"
            content="https://opengraph.b-cdn.net/production/images/615a02c6-2923-48d9-b1ec-50c6e27c5d06.png?token=JmMVYG07SFugbkLOXnU2VTn_7tFDja2Sx-LdZtIxFAY&height=800&width=1200&expires=33295584976"
        />
        <!-- Twitter Meta Tags -->
        <meta name="twitter:card" content="summary_large_image" />
        <meta property="twitter:domain" content="osho.is-a.dev" />
        <meta property="twitter:url" content="https://osho.is-a.dev/p2p.vc/" />
        <meta name="twitter:title" content="P2P Group Calling" />
        <meta name="twitter:description" content="" />
        <meta
            name="twitter:image"
            content="https://opengraph.b-cdn.net/production/images/615a02c6-2923-48d9-b1ec-50c6e27c5d06.png?token=JmMVYG07SFugbkLOXnU2VTn_7tFDja2Sx-LdZtIxFAY&height=800&width=1200&expires=33295584976"
        />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- Tailwind CSS + DaisyUI -->
        <link
            href="https://cdn.jsdelivr.net/npm/daisyui@4.12.14/dist/full.min.css"
            rel="stylesheet"
            type="text/css"
        />
        <script src="https://cdn.tailwindcss.com"></script>
        <link
            rel="stylesheet"
            href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.2.0/css/all.min.css"
        />
        <title>p2p.vc</title>
        <style>
            /* Custom light mode color scheme - professional and attractive */
            [data-theme="light"] {
                --b2: #f8fafc; /* Slightly off-white */
                --b3: #e5e7eb; /* Light gray borders */
                --bc: #1f2937; /* Dark text */
                --inc: #6b7280; /* Muted text */
                --su: #10b981; /* Success green */
                --rounded-box: 1rem; /* Rounded corners for cards */
                --rounded-btn: 0.5rem; /* Rounded buttons */
            }

            .video-container {
                position: relative;
                padding: 0rem;
                box-shadow: none;
            }
            .status-icons {
                position: absolute;
                bottom: 10px;
                right: 10px;
                display: flex;
                gap: 10px;
                z-index: 10;
            }
            .status-icons i {
                color: white;
                background-color: rgba(0, 0, 0, 0.5);
                padding: 5px;
                border-radius: 5px;
            }
            .video-container .info {
                position: absolute;
                bottom: 10px;
                left: 10px;
                background-color: rgba(0, 0, 0, 0.5);
                color: white;
                padding: 5px;
                border-radius: 5px;
                display: flex;
                align-items: center;
                gap: 10px;
                z-index: 10;
            }
            .video-container .info img {
                width: 30px;
                height: 30px;
                border-radius: 50%;
            }

            .hang-up-btn {
                position: absolute;
                border-radius: 10px !important;
                top: 10px;
                justify-self: anchor-center;
                display: none;
            }

            .full-scr-btn {
                position: absolute;
                border-radius: 10px !important;
                top: 10px;
                right: 10px;
                display: none;
            }

            .block-btn {
                position: absolute;
                border-radius: 10px !important;
                top: 10px;
                left: 10px;
                display: none;
            }

            .video-container:hover .hang-up-btn,
            .video-container:hover .full-scr-btn,
            .video-container:hover .block-btn {
                display: flex;
            }

            .controls {
                padding: var(--padding-card, 1rem);
            }

            /* Chat Panel Styles */
            .chat-panel {
                height: 60px;
                transition: height 0.3s ease-in-out;
                overflow: hidden;
                background-color: var(--b1);
            }

            .chat-panel.open {
                height: calc(60vh + 60px);
                background-color: var(--b1);
            }

            /* Ensure chat content has proper background when expanded */
            .chat-panel .chat-content {
                display: none;
            }

            .chat-panel.open .chat-content {
                display: block !important;
            }

            .chat-panel .dropdown:hover .dropdown-content {
                display: block;
            }

            .chat-messages {
                scroll-behavior: smooth;
            }

            .chat-message {
                padding: 6px 8px;
                border-radius: 8px;
                max-width: 85%;
                word-wrap: break-word;
            }

            .chat-message.own {
                background-color: var(--p, #3b82f6);
                color: var(--pc, #ffffff);
                text-align: right;
            }

            .chat-message.other {
                background-color: var(--b3, #e5e7eb);
                color: var(--bc, #1f2937);
            }

            .chat-message .sender {
                font-weight: 600;
                font-size: 0.75rem;
                margin-bottom: 2px;
                [data-theme="light"] & {
                    color: var(--inc, #6b7280);
                }
                [data-theme="dark"] & {
                    color: var(--inc, #d1d5db);
                }
            }

            .chat-message.own .sender {
                [data-theme="light"] & {
                    color: rgba(255, 255, 255, 0.8);
                }
                [data-theme="dark"] & {
                    color: rgba(255, 255, 255, 0.8);
                }
            }

            .chat-message .content {
                font-size: 0.875rem;
            }

            .chat-message .timestamp {
                font-size: 0.625rem;
                opacity: 0.7;
                margin-top: 2px;
            }
        </style>
    </head>
    <body class="bg-base-100">
        <!-- Hero Section -->
        <div class="bg-primary py-8">
            <div class="container mx-auto px-4">
                <h1 class="text-4xl font-bold text-primary-content">
                    p2p.vc (PeerJS)
                </h1>
                <p class="text-xl text-primary-content mt-2" id="my-id">
                    Your ID:
                </p>
                <p class="text-sm text-primary-content text-right">
                    Powered by yokto.js
                </p>
            </div>
        </div>

        <!-- Main Content -->
        <div class="container mx-auto px-4 py-8">
            <div class="flex flex-col lg:flex-row gap-6">
                <!-- Sidebar -->
                <div class="w-full lg:w-1/4 space-y-4">
                    <!-- Connect Box (Hidden) -->
                    <div
                        class="card bg-base-100 shadow-xl"
                        style="display: none"
                    >
                        <div class="card-body">
                            <div class="form-control">
                                <label class="label">
                                    <span class="label-text font-semibold"
                                        >Connect to Peer</span
                                    >
                                </label>
                                <input
                                    type="text"
                                    id="peer-id-input"
                                    placeholder="Enter Peer ID"
                                    class="input input-bordered w-full"
                                />
                            </div>
                            <div class="card-actions justify-start mt-2">
                                <button
                                    class="btn btn-primary"
                                    aria-label="Connect button"
                                    id="connect-btn"
                                >
                                    Connect
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Controls Card -->
                    <div class="card bg-primary shadow-xl">
                        <div class="card-body controls">
                            <h2 class="card-title text-primary-content">
                                Controls
                            </h2>
                            <div class="flex flex-wrap gap-2">
                                <button
                                    aria-label="Hangup button"
                                    class="btn btn-error btn-sm"
                                    id="hang-up-btn"
                                    title="Hang Up All Peer(s)"
                                >
                                    <i class="fas fa-trash"></i>
                                </button>
                                <button
                                    aria-label="Mute button"
                                    class="btn btn-neutral btn-sm"
                                    id="mute-audio-btn"
                                >
                                    <i class="fas fa-microphone-slash"></i>
                                </button>
                                <button
                                    aria-label="Disable video button"
                                    class="btn btn-neutral btn-sm"
                                    id="mute-video-btn"
                                >
                                    <i class="fas fa-video-slash"></i>
                                </button>
                                <button
                                    aria-label="Screen-share button"
                                    class="btn btn-neutral btn-sm tooltip"
                                    data-tip="Screen Sharing"
                                    id="share-screen-btn"
                                >
                                    <i class="fas fa-desktop"></i>
                                </button>
                                <button
                                    aria-label="Button for resetting ID"
                                    class="btn btn-neutral btn-sm"
                                    id="reset-id"
                                >
                                    Reset ID
                                </button>
                                <button
                                    aria-label="Preferences button"
                                    class="btn btn-info btn-sm"
                                    id="update-profile-btn"
                                >
                                    <i class="fas fa-gear"></i>
                                </button>
                                <button
                                    aria-label="Manage blocked peers button"
                                    class="btn btn-warning btn-sm"
                                    id="manage-blocked-btn"
                                    disabled
                                >
                                    <i class="fas fa-user-slash"></i>
                                </button>
                                <button
                                    aria-label="Toggle theme button"
                                    class="btn btn-neutral btn-sm"
                                    id="theme-toggle-btn"
                                >
                                    <i class="fas fa-moon" id="theme-icon"></i>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Available Peers Card -->
                    <div class="card bg-primary shadow-xl">
                        <div class="card-body p-0">
                            <h2
                                class="card-title text-primary-content px-4 pt-4 pb-2"
                            >
                                Available Peers
                            </h2>
                            <div id="peer-list" class="flex flex-col"></div>
                        </div>
                    </div>
                </div>

                <!-- Video Grid -->
                <div class="w-full lg:w-3/4 relative">
                    <div
                        id="videos"
                        class="grid grid-cols-1 md:grid-cols-2 gap-4"
                    >
                        <!-- Local Video -->
                        <div
                            class="card bg-base-100 shadow-xl video-container"
                            id="local-video-container"
                        >
                            <div class="card-body p-0">
                                <video
                                    id="local-video"
                                    class="rounded-2xl w-full"
                                    style="pointer-events: none"
                                    autoplay
                                    muted
                                ></video>
                                <div class="status-icons">
                                    <i
                                        class="fas fa-microphone-slash"
                                        id="local-audio-mute-icon"
                                        style="display: none"
                                    ></i>
                                    <i
                                        class="fas fa-video-slash"
                                        id="local-video-mute-icon"
                                        style="display: none"
                                    ></i>
                                </div>
                                <div class="info">
                                    <img
                                        id="local-avatar"
                                        src=""
                                        alt="Avatar"
                                    />
                                    <span id="local-name"></span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Chat Panel -->
                    <div
                        id="chat-panel"
                        class="chat-panel fixed bottom-0 left-0 bg-base-100 rounded-t-lg shadow-lg z-10"
                        style="width: 320px"
                    >
                        <!-- Chat Header/Handle -->
                        <div
                            id="chat-header"
                            class="flex items-center justify-between p-3 bg-primary rounded-t-lg cursor-pointer"
                            style="height: 60px"
                        >
                            <div
                                class="flex items-center gap-2 text-primary-content"
                            >
                                <i class="fas fa-comments"></i>
                                <span class="font-semibold text-sm">Chat</span>
                                <span
                                    id="unread-count"
                                    class="badge badge-sm bg-error text-error-content hidden"
                                ></span>
                            </div>
                            <div class="flex items-center gap-2">
                                <div class="dropdown dropdown-end">
                                    <div class="chat-settings-btn">
                                        <i
                                            class="fas fa-chevron-up text-primary-content text-sm"
                                        ></i>
                                    </div>
                                    <ul
                                        tabindex="0"
                                        class="dropdown-content menu bg-base-100 text-base-content rounded-box z-[1] w-48 p-2 shadow"
                                    >
                                        <li id="clear-chat-btn">
                                            <a class="text-error">
                                                <i class="fas fa-trash-alt"></i>
                                                Clear Chat
                                            </a>
                                        </li>
                                    </ul>
                                </div>
                                <div class="text-primary-content">
                                    <i class="fas fa-times text-sm"></i>
                                </div>
                            </div>
                        </div>

                        <!-- Chat Content -->
                        <div
                            id="chat-content"
                            class="chat-content bg-base-100"
                            style="position: relative; height: 60vh"
                        >
                            <!-- Messages Container -->
                            <div
                                id="chat-messages"
                                class="messages"
                                style="
                                    position: absolute;
                                    top: 0;
                                    left: 0;
                                    right: 0;
                                    bottom: 60px;
                                    overflow-y: auto;
                                    padding: 8px 12px;
                                    scroll-behavior: smooth;
                                "
                            ></div>

                            <!-- Message Input - Fixed at bottom -->
                            <div
                                class="message-input border-t border-base-content/20 bg-base-content/5"
                                style="
                                    position: absolute;
                                    bottom: 0;
                                    left: 0;
                                    right: 0;
                                    height: 60px;
                                    padding: 12px;
                                "
                            >
                                <form
                                    id="chat-form"
                                    class="flex gap-2 w-full h-full"
                                >
                                    <input
                                        type="text"
                                        id="chat-input"
                                        placeholder="Type a message..."
                                        class="input input-bordered input-sm flex-1"
                                        maxlength="500"
                                        autocomplete="off"
                                        style="height: 100%; margin: 0"
                                    />
                                    <button
                                        type="button"
                                        class="btn btn-primary btn-sm"
                                        id="send-chat-btn"
                                        style="
                                            height: 100%;
                                            padding-left: 12px;
                                            padding-right: 12px;
                                        "
                                    >
                                        <i class="fas fa-paper-plane"></i>
                                    </button>
                                </form>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Call Notification (Toast/Alert) -->
        <div
            id="call-notification"
            class="alert alert-info shadow-lg"
            style="
                display: none;
                position: fixed;
                top: 80px;
                right: 20px;
                z-index: 1000;
                max-width: 400px;
            "
        >
            <div>
                <svg
                    xmlns="http://www.w3.org/2000/svg"
                    fill="none"
                    viewBox="0 0 24 24"
                    class="stroke-current flex-shrink-0 w-6 h-6"
                >
                    <path
                        stroke-linecap="round"
                        stroke-linejoin="round"
                        stroke-width="2"
                        d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z"
                    ></path>
                </svg>
                <span id="call-notification-text"></span>
            </div>
            <div class="flex gap-2">
                <button
                    aria-label="Accept button"
                    id="accept-call-btn"
                    class="btn btn-success btn-sm"
                >
                    Accept
                </button>
                <button
                    aria-label="Deny button"
                    id="deny-call-btn"
                    class="btn btn-error btn-sm"
                >
                    Deny
                </button>
            </div>
        </div>

        <!-- Profile Modal -->
        <dialog id="profile-modal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg">Update Profile</h3>
                <div class="py-4 space-y-4">
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">Name</span>
                        </label>
                        <input
                            type="text"
                            id="name-input"
                            placeholder="Enter your name"
                            class="input input-bordered w-full"
                        />
                    </div>
                    <div class="form-control">
                        <label class="label">
                            <span class="label-text">Avatar URL</span>
                        </label>
                        <input
                            type="url"
                            id="avatar-input"
                            placeholder="https://example.com/avatar.jpg"
                            class="input input-bordered w-full"
                        />
                        <label class="label">
                            <span class="label-text-alt text-base-content/60"
                                >Enter a direct image URL (optional)</span
                            >
                        </label>
                    </div>
                </div>
                <div class="modal-action">
                    <button
                        aria-label="Save button"
                        id="save-profile-btn"
                        class="btn btn-success"
                    >
                        Save changes
                    </button>
                    <button aria-label="Cancel button" class="btn">
                        Cancel
                    </button>
                </div>
            </div>
            <form method="dialog" class="modal-backdrop">
                <button>close</button>
            </form>
        </dialog>

        <!-- Blocked Peers Modal -->
        <dialog id="blocked-peers-modal" class="modal">
            <div class="modal-box">
                <h3 class="font-bold text-lg flex items-center gap-2">
                    <i class="fas fa-user-slash"></i>
                    Blocked Peers
                </h3>
                <div class="py-4">
                    <div id="blocked-peers-list" class="space-y-2">
                        <!-- Blocked peers will be populated here -->
                    </div>
                    <div
                        id="no-blocked-peers"
                        class="text-center py-8 text-base-content/60"
                        style="display: none"
                    >
                        <i class="fas fa-check-circle text-4xl mb-2"></i>
                        <p>No blocked peers</p>
                    </div>
                </div>
                <div class="modal-action">
                    <button
                        aria-label="Close button"
                        class="btn"
                        id="close-blocked-modal-btn"
                    >
                        Close
                    </button>
                </div>
            </div>
            <form method="dialog" class="modal-backdrop">
                <button>close</button>
            </form>
        </dialog>

        <script src="https://unpkg.com/peerjs@1.4.7/dist/peerjs.min.js"></script>
        <script src="https://cdn.jsdelivr.net/gh/profxadke/yokto.js@main/yokto.min.js"></script>
        <script>
            // $$() is yokto.js's document.ready equivalent - runs when DOM is loaded
            $$(() => {
                // ============================================================
                // DOM ELEMENT REFERENCES (using yokto.js $ selector)
                // ============================================================

                const localVideo = $("#local-video"); // Local user's video element
                const videosContainer = $("#videos"); // Container for all video elements
                const myIdSpan = $("#my-id"); // Display element for user's peer ID
                const peerIdInput = $("#peer-id-input"); // Input field for manually entering peer ID
                const connectBtn = $("#connect-btn"); // Button to initiate connection
                const hangUpBtn = $("#hang-up-btn"); // Button to hang up all calls
                const muteAudioBtn = $("#mute-audio-btn"); // Toggle audio mute
                const muteVideoBtn = $("#mute-video-btn"); // Toggle video mute
                const shareScreenBtn = $("#share-screen-btn"); // Toggle screen sharing
                const resetIdBtn = $("#reset-id"); // Generate new peer ID
                const peerList = $("#peer-list"); // List of available peers
                const callNotification = $("#call-notification"); // Incoming call notification popup
                const callNotificationText = $("#call-notification-text"); // Text in notification
                const acceptCallBtn = $("#accept-call-btn"); // Accept incoming call
                const denyCallBtn = $("#deny-call-btn"); // Deny incoming call
                const updateProfileBtn = $("#update-profile-btn"); // Open profile settings modal
                const profileModal = $("#profile-modal"); // Profile settings modal
                const nameInput = $("#name-input"); // Input for user's display name
                const avatarInput = $("#avatar-input"); // Input for user's avatar URL
                const saveProfileBtn = $("#save-profile-btn"); // Save profile changes
                const manageBlockedBtn = $("#manage-blocked-btn"); // Button to open blocked peers modal
                const blockedPeersModal = $("#blocked-peers-modal"); // Blocked peers modal
                const blockedPeersList = $("#blocked-peers-list"); // Container for blocked peers list
                const noBlockedPeers = $("#no-blocked-peers"); // Message when no peers are blocked
                const closeBlockedModalBtn = $("#close-blocked-modal-btn"); // Close blocked modal button
                const themeToggleBtn = $("#theme-toggle-btn"); // Theme toggle button
                const themeIcon = $("#theme-icon"); // Icon inside theme toggle button
                const chatPanel = $("#chat-panel"); // Chat panel container
                const chatHeader = $("#chat-header"); // Chat header/handle
                const chatContent = $("#chat-content"); // Chat content container
                const chatMessagesEl = $("#chat-messages"); // Messages container
                const chatForm = $("#chat-form"); // Chat message form
                const chatInput = $("#chat-input"); // Chat input field
                const sendChatBtn = $("#send-chat-btn"); // Send chat message button
                const clearChatBtn = $("#clear-chat-btn"); // Clear chat button
                const unreadCount = $("#unread-count"); // Unread messages counter
                const localVideoContainer = $("#local-video-container"); // Container for local video
                const localAudioMuteIcon = $("#local-audio-mute-icon"); // Icon showing local audio is muted
                const localVideoMuteIcon = $("#local-video-mute-icon"); // Icon showing local video is muted
                const localAvatar = $("#local-avatar"); // User's avatar image
                const localName = $("#local-name"); // User's display name

                // ============================================================
                // STATE VARIABLES
                // ============================================================

                let localStream; // MediaStream object containing local audio/video tracks
                let peer; // PeerJS Peer object - represents this user in the peer network
                const calls = new Map(); // Map<peerId, MediaConnection> - stores active media calls
                const dataConnections = new Map(); // Map<peerId, {connection, metadata, timeoutId}> - stores data channels
                let incomingCall; // Stores pending incoming call details: {conn, metadata, muteStatus}
                let isScreenSharing = false; // Flag indicating if user is currently sharing screen
                let cameraStream; // Cached camera MediaStream for switching back from screen share
                const outgoingCallsInProgress = new Set(); // Set<peerId> - prevents accepting incoming call from peer we're calling
                const iceCandidateQueues = new Map(); // Map<peerId, Array<RTCIceCandidate>> - queues ICE candidates received before remote description is set
                const callTimers = new Map(); // Map<peerId, {startTime, intervalId}> - tracks call duration timers

                // ===================
                // CHAT SYSTEM STATE
                // ===================
                let chatMessages = []; // Array of chat messages
                let unreadMessages = 0; // Number of unread messages
                let isChatOpen = false; // Whether chat panel is expanded

                // ============================================================
                // USER METADATA
                // ============================================================

                const localMetadata = {
                    name:
                        localStorage.getItem("userName") || // Retrieve saved name or generate random
                        "User" + Math.floor(Math.random() * 1000),
                    avatar_url:
                        localStorage.getItem("userAvatarUrl") || // Retrieve saved avatar or generate random
                        "https://osho.is-a.dev/p2p.vc/avatar.png",
                    custom: {
                        status: "Available", // Custom status field (extensible)
                    },
                };

                // Set initial local metadata display using yokto.js
                localAvatar.attrs.src = localMetadata.avatar_url; // Set avatar image src attribute
                localName.text = localMetadata.name; // Set display name text

                // ============================================================
                // BLOCKED PEERS LIST (persisted in localStorage)
                // ============================================================

                let blockedPeers = new Set(
                    JSON.parse(localStorage.getItem("blockedPeers") || "[]"),
                );

                // ============================================================
                // HELPER FUNCTIONS
                // ============================================================

                /**
                 * Generates a random 6-digit peer ID (100000-999999)
                 * @returns {string} 6-digit numeric ID as string
                 */
                function generatePeerId() {
                    return String(Math.floor(Math.random() * 9e5) + 1e5);
                }

                /**
                 * Formats elapsed time in seconds to HH:MM:SS or MM:SS
                 * @param {number} seconds - Total seconds elapsed
                 * @returns {string} Formatted time string
                 */
                function formatCallDuration(seconds) {
                    const hours = Math.floor(seconds / 3600);
                    const minutes = Math.floor((seconds % 3600) / 60);
                    const secs = seconds % 60;

                    if (hours > 0) {
                        return `${hours}:${String(minutes).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
                    }
                    return `${minutes}:${String(secs).padStart(2, "0")}`;
                }

                /**
                 * Starts a call timer for a peer
                 * Updates the timer display every second
                 * @param {string} peerId - Peer ID to start timer for
                 */
                function startCallTimer(peerId) {
                    // Stop any existing timer for this peer first
                    stopCallTimer(peerId);

                    const startTime = Date.now();

                    const updateTimer = () => {
                        const elapsed = Math.floor(
                            (Date.now() - startTime) / 1000,
                        );
                        const timerElement = document.querySelector(
                            `.video-container[data-peer-id="${peerId}"] .call-timer`,
                        );
                        if (timerElement) {
                            timerElement.textContent =
                                formatCallDuration(elapsed);
                            console.log(
                                `Updated timer for ${peerId}: ${formatCallDuration(elapsed)}`,
                            );
                        } else {
                            console.warn(
                                `Timer element not found for ${peerId}`,
                            );
                        }
                    };

                    // Update immediately
                    updateTimer();

                    // Update every second
                    const intervalId = setInterval(updateTimer, 1000);

                    callTimers.set(peerId, { startTime, intervalId });
                    console.log(`Started call timer for ${peerId}`, {
                        startTime,
                        intervalId,
                    });
                }

                /**
                 * Stops and clears the call timer for a peer
                 * @param {string} peerId - Peer ID to stop timer for
                 */
                function stopCallTimer(peerId) {
                    const timer = callTimers.get(peerId);
                    if (timer) {
                        clearInterval(timer.intervalId);
                        callTimers.delete(peerId);
                        console.log(`Stopped call timer for ${peerId}`);
                    }
                }

                // ===================
                // CHAT SYSTEM FUNCTIONS
                // ===================

                /**
                 * Toggles the chat panel visibility
                 */
                function toggleChatPanel() {
                    if (isChatOpen) {
                        hideChatPanel();
                    } else {
                        showChatPanel();
                    }
                }

                /**
                 * Shows the chat panel
                 */
                function showChatPanel() {
                    chatPanel.$.node.classList.add("open");
                    setTimeout(() => {
                        // Add display block after animation starts
                        const chatContentElement =
                            document.getElementById("chat-content");
                        chatContentElement.style.display = "block";
                        // Scroll to bottom to show latest messages
                        const messagesElement =
                            document.getElementById("chat-messages");
                        if (messagesElement) {
                            messagesElement.scrollTop =
                                messagesElement.scrollHeight;
                        }
                    }, 50); // Short delay to start after animation begins
                    isChatOpen = true;
                    unreadMessages = 0;
                    updateUnreadCount();
                    updateChatHeader();
                }

                /**
                 * Hides the chat panel
                 */
                function hideChatPanel() {
                    chatPanel.$.node.classList.remove("open");
                    chatContent.$.node.style.display = "none";
                    isChatOpen = false;
                    updateUnreadCount();
                    updateChatHeader();
                }

                /**
                 * Adds a chat message to the messages array and UI
                 * @param {Object} message - {senderId, senderName, content, timestamp, isOwn}
                 */
                function addChatMessage(senderId, senderName, content) {
                    const message = {
                        senderId,
                        senderName,
                        content: content.trim(),
                        timestamp: new Date(),
                        isOwn: senderId === peer.id,
                    };

                    chatMessages.push(message);
                    renderChatMessage(message);

                    // If chat is closed, increment unread count
                    if (!isChatOpen) {
                        unreadMessages++;
                        updateUnreadCount();
                    }
                }

                /**
                 * Renders a chat message in the UI
                 * @param {Object} message - Message object to render
                 */
                function renderChatMessage(message) {
                    const messageEl = document.createElement("div");
                    messageEl.className = `chat-message ${message.isOwn ? "own" : "other"}`;

                    const senderSpan = document.createElement("div");
                    senderSpan.className = "sender";
                    senderSpan.textContent = message.senderName;

                    const contentSpan = document.createElement("div");
                    contentSpan.className = "content";
                    contentSpan.textContent = message.content;

                    const timestampSpan = document.createElement("div");
                    timestampSpan.className = "timestamp";
                    timestampSpan.textContent = formatMessageTime(
                        message.timestamp,
                    );

                    messageEl.appendChild(senderSpan);
                    messageEl.appendChild(contentSpan);
                    messageEl.appendChild(timestampSpan);

                    const messagesElement =
                        document.getElementById("chat-messages");
                    messagesElement.appendChild(messageEl);

                    // Auto-scroll to bottom only if chat is open
                    if (isChatOpen) {
                        setTimeout(() => {
                            messagesElement.scrollTop =
                                messagesElement.scrollHeight;
                        }, 10);
                    }
                }

                /**
                 * Formats a timestamp for chat messages
                 * @param {Date} date - Date object
                 * @returns {string} Formatted time string
                 */
                function formatMessageTime(date) {
                    const hours = date.getHours().toString().padStart(2, "0");
                    const minutes = date
                        .getMinutes()
                        .toString()
                        .padStart(2, "0");
                    return `${hours}:${minutes}`;
                }

                /**
                 * Updates the unread messages counter
                 */
                function updateUnreadCount() {
                    if (unreadMessages > 0 && !isChatOpen) {
                        unreadCount.$.node.textContent =
                            unreadMessages > 99 ? "99+" : unreadMessages;
                        unreadCount.$.node.classList.remove("hidden");
                    } else {
                        unreadCount.$.node.classList.add("hidden");
                    }
                }

                /**
                 * Updates the chat header indicator
                 */
                function updateChatHeader() {
                    const chevronIcon = document.querySelector(
                        ".chat-settings-btn i",
                    );
                    if (chevronIcon) {
                        chevronIcon.className = `fas fa-chevron-${isChatOpen ? "down" : "up"} text-primary-content text-sm`;
                    }
                }

                /**
                 * Sends a chat message to all connected peers
                 * @param {string} message - Message content
                 */
                function sendChatMessage(message) {
                    if (!message.trim()) return;

                    // Add message to local chat
                    addChatMessage(peer.id, localMetadata.name, message);

                    // Send message via data connections to all connected peers
                    for (const [
                        peerId,
                        dataConn,
                    ] of dataConnections.entries()) {
                        if (dataConn.connection && dataConn.connection.open) {
                            dataConn.connection.send({
                                type: "chat",
                                senderId: peer.id,
                                senderName: localMetadata.name,
                                content: message.trim(),
                            });
                        }
                    }

                    // Clear input
                    chatInput.$.node.value = "";
                }

                /**
                 * Clears all chat messages
                 */
                function clearChatMessages() {
                    chatMessages.length = 0;
                    const messagesElement =
                        document.getElementById("chat-messages");
                    messagesElement.innerHTML = "";
                    unreadMessages = 0;
                    updateUnreadCount();
                }

                // ============================================================
                // INITIALIZATION - Request camera/microphone access
                // ============================================================

                // Request access to user's camera and microphone
                navigator.mediaDevices
                    .getUserMedia({ video: true, audio: true })
                    .then((stream) => {
                        localStream = stream; // Store the media stream
                        cameraStream = stream; // Cache camera stream for screen share toggle
                        localVideo.$.node.srcObject = stream; // Display local video (yokto.js .$.node gets raw DOM element)
                        initializePeer(); // Once media is ready, initialize PeerJS connection
                    })
                    .catch((error) => {
                        console.error("Error accessing media devices.", error);
                    });

                /**
                 * Initializes PeerJS connection with signaling server and TURN/STUN configuration
                 * - Retrieves or generates peer ID
                 * - Connects to PeerJS signaling server
                 * - Configures TURN/STUN servers for NAT traversal
                 * - Sets up event listeners for peer events
                 */
                function initializePeer() {
                    // Retrieve existing peer ID from localStorage or generate new one
                    let peerId = localStorage.getItem("peerId");
                    if (!peerId) {
                        peerId = generatePeerId();
                        localStorage.setItem("peerId", peerId); // Persist for future sessions
                    }

                    // Create PeerJS peer object
                    peer = new Peer(peerId, {
                        host: "dev.blackstonenp.com", // PeerJS signaling server hostname
                        port: 443, // HTTPS port
                        path: "/app", // Path on signaling server
                        key: "xadkeg", // Authentication key for PeerJS server
                        config: {
                            // WebRTC configuration
                            iceServers: [
                                {
                                    url: "stun:dev.blackstonenp.com:3478", // STUN server for discovering public IP
                                },
                                {
                                    url: "turn:dev.blackstonenp.com:3478", // TURN server for relaying when direct connection fails
                                    username: "xadkeg", // TURN authentication
                                    credential: "passw0rd",
                                },
                            ],
                        },
                    });

                    // ============================================================
                    // PEER EVENT: 'open' - Successfully connected to signaling server
                    // ============================================================
                    peer.on("open", (id) => {
                        myIdSpan.text = `Your ID: ${id}`; // Display peer ID to user
                        updatePeerList(); // Fetch and display available peers
                        setInterval(updatePeerList, 1e4); // Refresh peer list every 10 seconds
                        setInterval(checkConnectedPeers, 15e3); // Check connected peers health every 15 seconds
                    });

                    // ============================================================
                    // PEER EVENT: 'call' - Incoming media connection (audio/video)
                    // ============================================================
                    peer.on("call", (call) => {
                        console.log(
                            `peer.on('call'): Local peer ID: ${peer.id}, Incoming call peer ID: ${call.peer}`,
                        );

                        // Ignore call from self (shouldn't happen but safety check)
                        if (call.peer === peer.id) {
                            console.log(
                                `peer.on('call'): Ignoring incoming call from self (${call.peer})`,
                            );
                            return;
                        }

                        // If we're already calling this peer, ignore their incoming call (race condition prevention)
                        if (outgoingCallsInProgress.has(call.peer)) {
                            console.log(
                                `peer.on('call'): Ignoring incoming call from ${call.peer} because an outgoing call is in progress.`,
                            );
                            return;
                        }

                        console.log(
                            `peer.on('call'): Incoming call from ${call.peer}`,
                        );

                        // Answer the call with our local media stream
                        call.answer(localStream);
                        call.localStream = localStream; // Store reference to our stream

                        console.log(
                            `peer.on('call'): Answered call from ${call.peer}`,
                        );
                        console.log(
                            `peer.on('call'): Connection state after answer: ${call.peerConnection.connectionState}`,
                        );
                        console.log(
                            `peer.on('call'): ICE connection state after answer: ${call.peerConnection.iceConnectionState}`,
                        );

                        handleCall(call); // Set up video display and event handlers
                    });

                    // ============================================================
                    // PEER EVENT: 'connection' - Incoming data connection
                    // ============================================================
                    peer.on("connection", (conn) => {
                        handleDataConnection(conn); // Set up data channel for signaling
                    });

                    // ============================================================
                    // PEER EVENT: 'error' - PeerJS error occurred
                    // ============================================================
                    peer.on("error", (err) => {
                        console.error("PeerJS error:", err);
                    });
                }

                /**
                 * Handles an active media call (incoming or outgoing)
                 * - Creates video UI element using yokto.js
                 * - Sets up remote stream display
                 * - Handles ICE candidate exchange
                 * - Manages call lifecycle events
                 *
                 * @param {MediaConnection} call - PeerJS MediaConnection object
                 */
                function handleCall(call) {
                    // Only process if this is a new call (not already in calls Map)
                    if (!calls.has(call.peer)) {
                        // ============================================================
                        // ICE CANDIDATE QUEUE PROCESSING
                        // ICE candidates may arrive before remote description is set
                        // Queue them and process when remote description is ready
                        // ============================================================
                        const processQueuedCandidates = async () => {
                            const queue = iceCandidateQueues.get(call.peer);
                            // Only process if remote description is set and queue exists
                            if (
                                call.peerConnection.remoteDescription &&
                                queue
                            ) {
                                console.log(
                                    `handleCall: Processing ${queue.length} queued ICE candidates for ${call.peer}.`,
                                );
                                // Process all queued candidates
                                while (queue.length > 0) {
                                    const candidate = queue.shift();
                                    try {
                                        await call.peerConnection.addIceCandidate(
                                            candidate,
                                        );
                                    } catch (e) {
                                        console.error(
                                            `Error adding queued ICE candidate for ${call.peer}:`,
                                            e,
                                        );
                                    }
                                }
                            }
                        };
                        processQueuedCandidates(); // Process any candidates that arrived early
                        // Re-process if signaling state changes (e.g., remote description set)
                        call.peerConnection.addEventListener(
                            "signalingstatechange",
                            processQueuedCandidates,
                        );

                        // ============================================================
                        // BUILD VIDEO UI USING YOKTO.JS VNODES
                        // $v() creates virtual DOM nodes
                        // ============================================================

                        // Outer column wrapper (no wrapper needed, will be direct child of grid)
                        const videoColumn = $v("div", {
                            class: "", // Empty, the parent is already a grid
                        });

                        // Video container card with peer ID for identification
                        const videoBox = $v("div", {
                            class: "card bg-base-100 shadow-xl video-container",
                            "data-peer-id": call.peer, // Store peer ID for later reference
                        });

                        // Remote video element
                        const remoteVideo = $v("video", {
                            autoplay: "true", // Auto-play when stream arrives
                            class: "rounded-2xl w-full",
                            style: "pointer-events: none;",
                        });
                        // Prevent video from being paused
                        remoteVideo._.on("pause", (e) => {
                            e.preventDefault();
                        });

                        // Status icons container (shows mute status)
                        const statusIcons = $v(
                            "div",
                            { class: "status-icons" },
                            [
                                $v("i", {
                                    class: "fas fa-microphone-slash", // Audio muted icon
                                    style: "display: none;", // Hidden by default
                                }),
                                $v("i", {
                                    class: "fas fa-video-slash", // Video muted icon
                                    style: "display: none;", // Hidden by default
                                }),
                            ],
                        );

                        // Retrieve peer metadata (name, avatar) from data connection
                        const metadata = dataConnections.get(
                            call.peer,
                        )?.metadata;
                        const infoChildren = [];
                        if (metadata) {
                            infoChildren.push(
                                $v("img", { src: metadata.avatar_url }), // Avatar image
                            );
                            infoChildren.push($v("span", {}, metadata.name)); // Display name
                        }
                        // Info overlay showing peer identity
                        const info = $v("div", { class: "info" }, infoChildren);

                        // Call timer overlay (bottom center)
                        const callTimer = $v(
                            "div",
                            {
                                class: "call-timer",
                                style: "position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%); background-color: rgba(0, 0, 0, 0.7); color: white; padding: 4px 12px; border-radius: 12px; font-size: 14px; font-weight: 600; z-index: 10; font-family: monospace;",
                            },
                            "0:00",
                        );

                        // ============================================================
                        // CONTROL BUTTONS (hang up, block, fullscreen)
                        // ============================================================

                        // Hang up button (disconnect from this peer)
                        const hangUpBtn = $v(
                            "button",
                            {
                                class: "btn btn-error btn-sm hang-up-btn",
                            },
                            $v("i", { class: "fas fa-phone-slash" }),
                        );
                        hangUpBtn._.on("click", () => hangUpPeer(call.peer)); // Disconnect this peer

                        // Block button
                        const blockBtn = $v(
                            "button",
                            {
                                class: "btn btn-warning btn-sm block-btn",
                            },
                            $v("i", { class: "fas fa-trash" }),
                        );
                        blockBtn._.on("click", () => blockPeer(call.peer)); // Add peer to block list

                        // Fullscreen function - handles browser compatibility
                        const toFullScr = () => {
                            const video = remoteVideo.$.node; // Get raw DOM node
                            if (video.requestFullscreen)
                                video.requestFullscreen(); // Standard
                            else if (video.webkitRequestFullscreen)
                                video.webkitRequestFullscreen(); // Safari
                            else if (video.msRequestFullScreen)
                                video.msRequestFullScreen(); // IE/Edge
                            else fullScrBtn._.remove(); // Fullscreen not supported, remove button
                        };

                        // Fullscreen button
                        const fullScrIco = $v("i", { class: "fas fa-expand" });
                        fullScrIco._.on("click", () => {
                            toFullScr();
                        });
                        const fullScrBtn = $v(
                            "button",
                            {
                                class: "btn btn-info btn-sm full-scr-btn",
                            },
                            fullScrIco,
                        );
                        fullScrBtn._.on("click", () => {
                            toFullScr();
                        });

                        // ============================================================
                        // ASSEMBLE AND MOUNT VIDEO UI
                        // ._.append() adds child to vNode
                        // _(child, parent) mounts child into parent
                        // ============================================================
                        videoBox._.append(remoteVideo);
                        videoBox._.append(fullScrBtn);
                        videoBox._.append(statusIcons);
                        videoBox._.append(info);
                        videoBox._.append(callTimer); // Add call timer
                        videoBox._.append(hangUpBtn);
                        videoBox._.append(blockBtn);
                        videoColumn._.append(videoBox);
                        _(videoColumn, videosContainer); // Mount to main videos container

                        // ============================================================
                        // WEBRTC STREAM HANDLING
                        // ============================================================

                        // Listen for media tracks (more reliable than PeerJS 'stream' event)
                        call.peerConnection.ontrack = (event) => {
                            console.log(
                                `handleCall: RTCPeerConnection ontrack event for ${call.peer}`,
                                event,
                            );
                            const remoteStream = event.streams[0]; // Get remote peer's media stream
                            if (remoteStream) {
                                remoteVideo.$.node.srcObject = remoteStream; // Display remote video
                                call.remoteStream = remoteStream; // Store reference
                                console.log(
                                    `handleCall: remoteVideo.srcObject updated via ontrack for ${call.peer}`,
                                );

                                // Start call timer when first track is received
                                // Use setTimeout to ensure DOM is fully mounted
                                if (!callTimers.has(call.peer)) {
                                    setTimeout(
                                        () => startCallTimer(call.peer),
                                        100,
                                    );
                                }
                            } else {
                                console.warn(
                                    `handleCall: No stream found in ontrack event for ${call.peer}`,
                                );
                            }
                        };

                        // ============================================================
                        // ICE CANDIDATE EXCHANGE
                        // Send our ICE candidates to remote peer via data channel
                        // ============================================================
                        call.peerConnection.onicecandidate = (event) => {
                            if (event.candidate) {
                                // Send ICE candidate to peer via data connection
                                dataConnections
                                    .get(call.peer)
                                    ?.connection.send({
                                        type: "ice-candidate",
                                        candidate: event.candidate.toJSON(),
                                    });
                                console.log(
                                    `handleCall: Sent ICE candidate to peer ${call.peer} during initial setup.`,
                                );
                            }
                        };

                        // ============================================================
                        // PEERJS CALL EVENT HANDLERS
                        // ============================================================

                        // 'stream' event - backup handler (ontrack is more reliable)
                        call.on("stream", (remoteStream) => {
                            console.log(
                                `handleCall: Stream received for ${call.peer}`,
                            );
                            remoteVideo.$.node.srcObject = remoteStream;
                            call.remoteStream = remoteStream;
                            outgoingCallsInProgress.delete(call.peer); // Call established, remove from outgoing set

                            // Start call timer when stream is established
                            startCallTimer(call.peer);
                        });

                        // 'close' event - cleanup when call ends
                        call.on("close", () => {
                            console.log(
                                `handleCall: Call closed for ${call.peer}`,
                            );
                            stopCallTimer(call.peer); // Stop and clear the timer
                            videoColumn._.remove(); // Remove video UI
                            calls.delete(call.peer); // Remove from active calls
                            outgoingCallsInProgress.delete(call.peer); // Remove from outgoing calls set
                            console.log(
                                `handleCall: Cleaned up call state for ${call.peer}. Outgoing calls in progress:`,
                                Array.from(outgoingCallsInProgress),
                            );
                        });

                        // Store call in active calls map
                        calls.set(call.peer, call);
                    }
                }

                /**
                 * Handles data connection for signaling (not media)
                 * Data connections are used to exchange:
                 * - Call requests/acceptance/denial
                 * - Mute status updates
                 * - ICE candidates
                 * - Hang up notifications
                 *
                 * @param {DataConnection} conn - PeerJS DataConnection object
                 */
                function handleDataConnection(conn) {
                    // Reject connections from blocked peers
                    if (blockedPeers.has(conn.peer)) {
                        conn.on("open", () => conn.close());
                        return;
                    }

                    // ============================================================
                    // DATA MESSAGE HANDLER - processes signaling messages
                    // ============================================================
                    conn.on("data", async (data) => {
                        const dataConn = dataConnections.get(conn.peer);

                        // Switch on message type
                        switch (data.type) {
                            case "call-request": {
                                // Remote peer wants to call us
                                // Show notification with accept/deny buttons
                                showCallNotification(conn, data.metadata, {
                                    audioMuted: data.audioMuted,
                                    videoMuted: data.videoMuted,
                                });
                                break;
                            }
                            case "call-accepted": {
                                // Remote peer accepted our call request
                                // Clear timeout and initiate media connection
                                if (dataConn?.timeoutId) {
                                    clearTimeout(dataConn.timeoutId); // Clear 30s timeout
                                }
                                handleCallAccepted(conn, data.metadata); // Store metadata
                                const mediaCall = peer.call(
                                    conn.peer,
                                    localStream, // Start media call with our stream
                                );
                                outgoingCallsInProgress.add(conn.peer); // Mark as outgoing call
                                console.log(
                                    `handleDataConnection: Added ${conn.peer} to outgoingCallsInProgress. Current set:`,
                                    Array.from(outgoingCallsInProgress),
                                );
                                handleCall(mediaCall); // Set up video UI and handlers
                                updateMuteStatus(conn.peer, {
                                    audioMuted: data.audioMuted,
                                    videoMuted: data.videoMuted,
                                });
                                break;
                            }
                            case "call-denied": {
                                // Remote peer denied our call request
                                if (dataConn?.timeoutId) {
                                    clearTimeout(dataConn.timeoutId);
                                }
                                alert(`${conn.peer} denied your call.`);
                                conn.close();
                                break;
                            }
                            case "hang-up": {
                                // Remote peer hung up
                                const call = calls.get(conn.peer);
                                if (call) call.close(); // Close media connection
                                conn.close(); // Close data connection
                                break;
                            }
                            case "mute-status": {
                                // Remote peer changed their mute status
                                console.log(
                                    `handleDataConnection: Received mute-status from ${conn.peer}`,
                                    data,
                                );
                                updateMuteStatus(conn.peer, data);
                                break;
                            }
                            case "ice-candidate": {
                                // Received ICE candidate from remote peer
                                console.log(
                                    `handleDataConnection: Received ICE candidate from ${conn.peer}.`,
                                );
                                const call = calls.get(conn.peer);
                                const candidate = new RTCIceCandidate(
                                    data.candidate,
                                );

                                // Only add if remote description is already set
                                if (
                                    call &&
                                    call.peerConnection &&
                                    call.peerConnection.remoteDescription
                                ) {
                                    try {
                                        await call.peerConnection.addIceCandidate(
                                            candidate,
                                        );
                                    } catch (e) {
                                        console.error(
                                            `Error adding ICE candidate for ${conn.peer}:`,
                                            e,
                                        );
                                    }
                                } else {
                                    // Queue candidate if remote description not ready yet
                                    if (!iceCandidateQueues.has(conn.peer)) {
                                        iceCandidateQueues.set(conn.peer, []);
                                    }
                                    iceCandidateQueues
                                        .get(conn.peer)
                                        .push(candidate);
                                    console.log(
                                        `Queued ICE candidate from ${conn.peer}.`,
                                    );
                                }
                                break;
                            }
                            case "chat": {
                                // Received chat message from peer
                                console.log(
                                    `handleDataConnection: Received chat message from ${conn.peer}`,
                                    data,
                                );
                                addChatMessage(
                                    data.senderId,
                                    data.senderName,
                                    data.content,
                                );
                                break;
                            }
                        }
                    });

                    // ============================================================
                    // DATA CONNECTION CLOSE HANDLER
                    // ============================================================
                    conn.on("close", () => {
                        // Hide notification if it was from this peer
                        if (
                            incomingCall &&
                            incomingCall.conn.peer === conn.peer
                        ) {
                            callNotification._.css({ display: "none" });
                            incomingCall = null;
                        }
                        dataConnections.delete(conn.peer); // Remove from data connections
                        const call = calls.get(conn.peer);
                        if (call) call.close(); // Close associated media call
                    });
                }

                /**
                 * Shows incoming call notification popup
                 * @param {DataConnection} conn - Data connection from caller
                 * @param {Object} metadata - Caller's metadata (name, avatar)
                 * @param {Object} muteStatus - Caller's mute status
                 */
                function showCallNotification(conn, metadata, muteStatus) {
                    incomingCall = { conn, metadata, muteStatus }; // Store for accept/deny handlers
                    callNotificationText.text = `Incoming call from ${metadata.name}`;
                    callNotification._.css({ display: "block" }); // Show notification
                }

                /**
                 * Handles successful call acceptance
                 * Stores connection and metadata in dataConnections map
                 * @param {DataConnection} conn - Data connection
                 * @param {Object} metadata - Remote peer's metadata
                 */
                function handleCallAccepted(conn, metadata) {
                    dataConnections.set(conn.peer, {
                        connection: conn,
                        metadata,
                    });
                }

                /**
                 * Updates mute status icons for a remote peer
                 * Shows/hides audio/video mute icons based on peer's status
                 * @param {string} peerId - Peer ID to update
                 * @param {Object} data - {audioMuted, videoMuted}
                 */
                function updateMuteStatus(peerId, data) {
                    console.log(
                        `updateMuteStatus: Updating mute status for ${peerId}`,
                        data,
                    );

                    // Find the video container for this peer using direct DOM query
                    const videoContainer = document.querySelector(
                        `.video-container[data-peer-id="${peerId}"]`,
                    );

                    if (videoContainer) {
                        console.log(
                            `updateMuteStatus: Found video container for ${peerId}`,
                        );

                        // Find the status icons container
                        const statusIconsDiv =
                            videoContainer.querySelector(".status-icons");

                        if (statusIconsDiv) {
                            // Find audio and video mute icons
                            const audioIcon = statusIconsDiv.querySelector(
                                ".fa-microphone-slash",
                            );
                            const videoIcon =
                                statusIconsDiv.querySelector(".fa-video-slash");

                            // Show/hide icons based on mute status
                            if (audioIcon) {
                                audioIcon.style.display = data.audioMuted
                                    ? "inline-block"
                                    : "none";
                                console.log(
                                    `updateMuteStatus: Set audio icon display to ${data.audioMuted ? "inline-block" : "none"}`,
                                );
                            } else {
                                console.warn(
                                    `updateMuteStatus: Audio icon not found for ${peerId}`,
                                );
                            }

                            if (videoIcon) {
                                videoIcon.style.display = data.videoMuted
                                    ? "inline-block"
                                    : "none";
                                console.log(
                                    `updateMuteStatus: Set video icon display to ${data.videoMuted ? "inline-block" : "none"}`,
                                );
                            } else {
                                console.warn(
                                    `updateMuteStatus: Video icon not found for ${peerId}`,
                                );
                            }
                        } else {
                            console.warn(
                                `updateMuteStatus: Status icons div not found for ${peerId}`,
                            );
                        }

                        // Explicitly re-assign srcObject to force a re-render
                        // This ensures video displays correctly after mute status change
                        const remoteVideo =
                            videoContainer.querySelector("video");
                        const call = calls.get(peerId);
                        if (remoteVideo && call && call.remoteStream) {
                            remoteVideo.srcObject = call.remoteStream;
                        }
                    } else {
                        console.warn(
                            `updateMuteStatus: Video container not found for ${peerId}`,
                        );
                    }
                }

                /**
                 * Blocks a peer permanently
                 * - Adds to blockedPeers set
                 * - Persists to localStorage
                 * - Closes active connections
                 * - Removes from peer list
                 *
                 * @param {string} peerId - Peer ID to block
                 */
                function blockPeer(peerId) {
                    blockedPeers.add(peerId); // Add to blocked set
                    localStorage.setItem(
                        "blockedPeers",
                        JSON.stringify([...blockedPeers]), // Persist to localStorage
                    );
                    const call = calls.get(peerId);
                    if (call) call.close(); // Close media call
                    const conn = dataConnections.get(peerId);
                    if (conn) conn.connection.close(); // Close data connection
                    updatePeerList(); // Refresh peer list (blocked peers won't show)
                    updateBlockedButton(); // Update blocked peers button state
                }

                /**
                 * Unblocks a peer
                 * - Removes from blockedPeers set
                 * - Updates localStorage
                 * - Refreshes peer list
                 *
                 * @param {string} peerId - Peer ID to unblock
                 */
                function unblockPeer(peerId) {
                    blockedPeers.delete(peerId); // Remove from blocked set
                    localStorage.setItem(
                        "blockedPeers",
                        JSON.stringify([...blockedPeers]), // Update localStorage
                    );
                    updatePeerList(); // Refresh peer list
                    updateBlockedButton(); // Update button state
                    populateBlockedPeersList(); // Refresh blocked peers modal
                    console.log(`Unblocked peer: ${peerId}`);
                }

                /**
                 * Updates the manage blocked peers button state
                 * - Enables button if there are blocked peers
                 * - Disables button if no blocked peers
                 */
                function updateBlockedButton() {
                    const hasBlockedPeers = blockedPeers.size > 0;
                    if (hasBlockedPeers) {
                        manageBlockedBtn.$.node.removeAttribute("disabled");
                    } else {
                        manageBlockedBtn.$.node.setAttribute(
                            "disabled",
                            "disabled",
                        );
                    }
                }

                /**
                 * Populates the blocked peers list in the modal
                 */
                function populateBlockedPeersList() {
                    // Clear existing list
                    blockedPeersList.$.node.innerHTML = "";

                    if (blockedPeers.size === 0) {
                        // Show "no blocked peers" message
                        blockedPeersList.$.node.style.display = "none";
                        noBlockedPeers.$.node.style.display = "block";
                    } else {
                        // Show blocked peers list
                        blockedPeersList.$.node.style.display = "block";
                        noBlockedPeers.$.node.style.display = "none";

                        // Create list items for each blocked peer
                        blockedPeers.forEach((peerId) => {
                            const peerItem = document.createElement("div");
                            peerItem.className =
                                "flex items-center justify-between p-3 bg-base-200 rounded-lg";

                            const peerIdSpan = document.createElement("span");
                            peerIdSpan.className = "font-mono font-semibold";
                            peerIdSpan.textContent = peerId;

                            const unblockBtn = document.createElement("button");
                            unblockBtn.className = "btn btn-success btn-sm";
                            unblockBtn.innerHTML =
                                '<i class="fas fa-user-check mr-1"></i> Unblock';
                            unblockBtn.addEventListener("click", () => {
                                unblockPeer(peerId);
                            });

                            peerItem.appendChild(peerIdSpan);
                            peerItem.appendChild(unblockBtn);
                            blockedPeersList.$.node.appendChild(peerItem);
                        });
                    }
                }

                /**
                 * Hangs up on a specific peer (without blocking)
                 * - Closes media connection
                 * - Sends hang-up notification to peer
                 * - Closes data connection
                 *
                 * @param {string} peerId - Peer ID to hang up on
                 */
                function hangUpPeer(peerId) {
                    const call = calls.get(peerId);
                    if (call) {
                        call.close(); // Close media connection
                    }
                    const conn = dataConnections.get(peerId);
                    if (conn && conn.connection) {
                        conn.connection.send({ type: "hang-up" }); // Notify peer we're hanging up
                        conn.connection.close(); // Close data connection
                    }
                }

                /**
                 * Replaces the local video track (used for screen sharing toggle)
                 * - Replaces video track in all active calls using RTCRtpSender.replaceTrack()
                 * - Stops old video track
                 * - Updates local stream and video display
                 *
                 * @param {MediaStreamTrack} newVideoTrack - New video track (camera or screen)
                 */
                async function replaceLocalVideoStream(newVideoTrack) {
                    console.log(
                        "replaceLocalVideoStream: Replacing video track.",
                    );

                    // Replace video track in all active peer connections
                    for (const call of calls.values()) {
                        // Find the video sender in this peer connection
                        const sender = call.peerConnection
                            .getSenders()
                            .find((s) => s.track && s.track.kind === "video");
                        if (sender) {
                            // Replace the track without renegotiation (seamless switch)
                            await sender.replaceTrack(newVideoTrack);
                            console.log(
                                `replaceLocalVideoStream: Replaced track for peer ${call.peer}.`,
                            );
                        } else {
                            console.warn(
                                `replaceLocalVideoStream: Could not find video sender for peer ${call.peer}.`,
                            );
                        }
                    }

                    // Stop the old video track to release camera/screen
                    const oldVideoTrack = localStream.getVideoTracks()[0];
                    if (oldVideoTrack) {
                        oldVideoTrack.stop();
                    }

                    // Create new local stream with audio + new video track
                    const audioTrack = localStream.getAudioTracks()[0];
                    localStream = new MediaStream([audioTrack, newVideoTrack]);

                    // Update local video display
                    localVideo.$.node.srcObject = localStream;
                }

                /**
                 * Fetches and displays list of available peers
                 * - Queries PeerJS server for all connected peers
                 * - Filters out self and blocked peers
                 * - Creates clickable list items using yokto.js
                 */
                function updatePeerList() {
                    peer.listAllPeers((peers) => {
                        peerList.text = ""; // Clear existing list
                        peers.forEach((p) => {
                            // Don't show self or blocked peers
                            if (p !== peer.id && !blockedPeers.has(p)) {
                                // Create clickable peer list item (DaisyUI button style)
                                const peerItem = $v(
                                    "button",
                                    {
                                        class: "btn btn-ghost justify-start w-full text-primary-content",
                                    },
                                    p, // Display peer ID
                                );
                                // Click to auto-fill and connect
                                peerItem._.on("click", () => {
                                    peerIdInput.$.node.value = p;
                                    connectBtn.$.node.click();
                                });
                                _(peerItem, peerList); // Mount to peer list
                            }
                        });
                    });
                }

                /**
                 * Health check for connected peers
                 * Closes calls to peers that are no longer online
                 * Called every 15 seconds
                 */
                function checkConnectedPeers() {
                    peer.listAllPeers((peers) => {
                        // Check each active call
                        for (const [peerId, call] of calls.entries()) {
                            // If peer is no longer in the network, close the call
                            if (!peers.includes(peerId)) {
                                call.close();
                            }
                        }
                    });
                }

                /**
                 * Initiates a call to a peer
                 * - Creates data connection to peer
                 * - Sends call-request with metadata
                 * - Sets 30-second timeout for response
                 * Called when user clicks Connect button or clicks peer in list
                 */
                function handleConnect() {
                    const peerId = peerIdInput.$.node.value.trim();
                    // Validate: peer ID exists, not calling self, not already connected
                    if (peerId && peerId !== peer.id && !calls.has(peerId)) {
                        const conn = peer.connect(peerId); // Create data connection

                        // Set 30-second timeout for call acceptance
                        const timeoutId = setTimeout(() => {
                            alert(`No answer from ${peerId}`);
                            conn.close();
                        }, 3e4); // 30 seconds = 30000ms

                        // When data connection opens, send call request
                        conn.on("open", () => {
                            dataConnections.set(peerId, {
                                connection: conn,
                                timeoutId, // Store timeout ID to clear if accepted
                            });
                            // Send call-request message with our metadata and mute status
                            conn.send({
                                type: "call-request",
                                metadata: localMetadata,
                                audioMuted:
                                    !localStream.getAudioTracks()[0].enabled,
                                videoMuted:
                                    !localStream.getVideoTracks()[0].enabled,
                            });
                        });
                        handleDataConnection(conn); // Set up data message handlers
                    }
                    peerIdInput.$.node.value = ""; // Clear input field
                }

                // ============================================================
                // EVENT HANDLERS - Accept/Deny Call
                // ============================================================

                /**
                 * ACCEPT CALL BUTTON
                 * - Sends 'call-accepted' message with our metadata
                 * - Stores connection and caller's metadata
                 * - Updates caller's mute status icons
                 * - Hides notification
                 * - Caller will then initiate media connection
                 */
                acceptCallBtn._.on("click", () => {
                    if (incomingCall) {
                        // Send acceptance message with our metadata and mute status
                        incomingCall.conn.send({
                            type: "call-accepted",
                            metadata: localMetadata,
                            audioMuted:
                                !localStream.getAudioTracks()[0].enabled,
                            videoMuted:
                                !localStream.getVideoTracks()[0].enabled,
                        });
                        // Store data connection and caller's metadata
                        dataConnections.set(incomingCall.conn.peer, {
                            connection: incomingCall.conn,
                            metadata: incomingCall.metadata,
                        });

                        // Update UI to show caller's mute status
                        updateMuteStatus(
                            incomingCall.conn.peer,
                            incomingCall.muteStatus,
                        );

                        callNotification._.css({ display: "none" }); // Hide notification
                        incomingCall = null; // Clear pending call
                    }
                });

                /**
                 * DENY CALL BUTTON
                 * - Sends 'call-denied' message
                 * - Closes connection
                 * - Hides notification
                 */
                denyCallBtn._.on("click", () => {
                    if (incomingCall) {
                        incomingCall.conn.send({ type: "call-denied" }); // Notify caller
                        incomingCall.conn.close(); // Close data connection
                        callNotification._.css({ display: "none" }); // Hide notification
                        incomingCall = null; // Clear pending call
                    }
                });

                // ============================================================
                // EVENT HANDLERS - Connection Controls
                // ============================================================

                /**
                 * PEER ID INPUT - Enter key triggers connect
                 */
                peerIdInput._.on("keyup", (event) => {
                    if (event.key === "Enter") handleConnect();
                });

                /**
                 * CONNECT BUTTON - Initiates call to entered peer ID
                 */
                connectBtn._.on("click", handleConnect);

                /**
                 * HANG UP ALL BUTTON - Disconnects from all peers
                 * - Sends hang-up message to all connected peers
                 * - Peers will close connections on their end
                 */
                hangUpBtn._.on("click", () => {
                    for (const [
                        peerId,
                        dataConn,
                    ] of dataConnections.entries()) {
                        if (dataConn.connection) {
                            dataConn.connection.send({ type: "hang-up" }); // Notify peer
                        }
                    }
                });

                // ============================================================
                // EVENT HANDLERS - Media Controls
                // ============================================================

                /**
                 * MUTE AUDIO BUTTON
                 * - Toggles audio track enabled state
                 * - Updates button icon
                 * - Shows/hides local mute icon
                 * - Notifies all peers of mute status change
                 */
                muteAudioBtn._.on("click", () => {
                    const audioTrack = localStream.getAudioTracks()[0];
                    audioTrack.enabled = !audioTrack.enabled; // Toggle audio

                    // Update button icon based on state
                    const icon = audioTrack.enabled
                        ? '<i class="fas fa-microphone"></i>' // Unmuted
                        : '<i class="fas fa-microphone-slash"></i>'; // Muted
                    muteAudioBtn.$.node.innerHTML = icon;

                    // Show/hide local mute indicator
                    localAudioMuteIcon._.css({
                        display: audioTrack.enabled ? "none" : "inline-block",
                    });

                    // Notify all connected peers of mute status change
                    const muteStatusMessage = {
                        type: "mute-status",
                        audioMuted: !audioTrack.enabled,
                        videoMuted: !localStream.getVideoTracks()[0].enabled,
                    };
                    console.log(
                        "Sending mute-status to all peers:",
                        muteStatusMessage,
                    );
                    for (const [
                        peerId,
                        dataConn,
                    ] of dataConnections.entries()) {
                        if (dataConn.connection) {
                            dataConn.connection.send(muteStatusMessage);
                            console.log(`Sent mute-status to ${peerId}`);
                        }
                    }
                });

                /**
                 * MUTE VIDEO BUTTON
                 * - Toggles video track enabled state (black screen when disabled)
                 * - Updates button icon
                 * - Shows/hides local mute icon
                 * - Notifies all peers of mute status change
                 */
                muteVideoBtn._.on("click", () => {
                    const videoTrack = localStream.getVideoTracks()[0];
                    videoTrack.enabled = !videoTrack.enabled; // Toggle video

                    // Update button icon based on state
                    const icon = videoTrack.enabled
                        ? '<i class="fas fa-video"></i>' // Video on
                        : '<i class="fas fa-video-slash"></i>'; // Video off
                    muteVideoBtn.$.node.innerHTML = icon;

                    // Show/hide local mute indicator
                    localVideoMuteIcon._.css({
                        display: videoTrack.enabled ? "none" : "inline-block",
                    });

                    // Notify all connected peers of mute status change
                    const muteStatusMessage = {
                        type: "mute-status",
                        audioMuted: !localStream.getAudioTracks()[0].enabled,
                        videoMuted: !videoTrack.enabled,
                    };
                    console.log(
                        "Sending mute-status to all peers:",
                        muteStatusMessage,
                    );
                    for (const [
                        peerId,
                        dataConn,
                    ] of dataConnections.entries()) {
                        if (dataConn.connection) {
                            dataConn.connection.send(muteStatusMessage);
                            console.log(`Sent mute-status to ${peerId}`);
                        }
                    }
                });

                /**
                 * SCREEN SHARE BUTTON
                 * - Toggles between camera and screen sharing
                 * - Replaces video track in all active calls
                 * - Auto-stops if user clicks "Stop sharing" in browser
                 */
                shareScreenBtn._.on("click", async () => {
                    // Guard against unsupported browsers (though button should be hidden)
                    if (!navigator.mediaDevices.getDisplayMedia) {
                        alert("Screen sharing is not supported on this device");
                        return;
                    }
                    if (isScreenSharing) {
                        // Switch back to camera
                        const newCameraStream =
                            await navigator.mediaDevices.getUserMedia({
                                video: true, // Request camera again
                            });
                        const newCameraVideoTrack =
                            newCameraStream.getVideoTracks()[0];
                        await replaceLocalVideoStream(newCameraVideoTrack);
                        isScreenSharing = false;
                        // Update button icon to "start screen share"
                        shareScreenBtn.$.node.innerHTML =
                            '<i class="fas fa-desktop"></i>';
                    } else {
                        // Switch to screen share
                        try {
                            const screenStream =
                                await navigator.mediaDevices.getDisplayMedia({
                                    video: true, // Request screen capture
                                });
                            const screenVideoTrack =
                                screenStream.getVideoTracks()[0];
                            await replaceLocalVideoStream(screenVideoTrack);
                            isScreenSharing = true;
                            // Update button icon to "stop screen share"
                            shareScreenBtn.$.node.innerHTML =
                                '<i class="fas fa-stop-circle"></i>';

                            // Auto-stop screen sharing if user clicks "Stop sharing" in browser
                            screenVideoTrack.onended = () => {
                                if (isScreenSharing) {
                                    shareScreenBtn.$.node.click(); // Trigger switch back to camera
                                }
                            };
                        } catch (error) {
                            console.error("Error sharing screen:", error);
                            // If screen sharing fails, reset state
                            isScreenSharing = false;
                            shareScreenBtn.$.node.innerHTML =
                                '<i class="fas fa-desktop"></i>';
                        }
                    }
                });

                /**
                 * RESET ID BUTTON
                 * - Destroys current peer connection
                 * - Generates new random peer ID
                 * - Re-initializes peer with new ID
                 */
                resetIdBtn._.on("click", () => {
                    peer.destroy(); // Disconnect from PeerJS server
                    let peerId = generatePeerId(); // Generate new ID
                    localStorage.setItem("peerId", peerId); // Save new ID
                    initializePeer(); // Reconnect with new ID
                });

                // ============================================================
                // EVENT HANDLERS - Blocked Peers Management
                // ============================================================

                /**
                 * MANAGE BLOCKED PEERS BUTTON
                 * Opens modal to view and unblock peers
                 */
                manageBlockedBtn._.on("click", () => {
                    populateBlockedPeersList(); // Populate the list
                    blockedPeersModal.$.node.showModal(); // Show modal
                });

                /**
                 * CLOSE BLOCKED MODAL BUTTON
                 * Closes the blocked peers modal
                 */
                closeBlockedModalBtn._.on("click", () => {
                    blockedPeersModal.$.node.close();
                });

                // ===================
                // THEME MANAGEMENT
                // ===================

                /**
                 * Initializes the theme based on stored preference or system preference
                 */
                function initializeTheme() {
                    // Get stored theme preference or default to light
                    const storedTheme = localStorage.getItem("theme");
                    const systemPrefersDark = window.matchMedia(
                        "(prefers-color-scheme: dark)",
                    ).matches;

                    let currentTheme = storedTheme;

                    // If no stored preference, use system preference, default to light
                    if (!currentTheme) {
                        currentTheme = systemPrefersDark ? "dark" : "light";
                    }

                    // Apply the theme
                    setTheme(currentTheme);
                }

                /**
                 * Sets the theme and updates UI
                 * @param {string} theme - 'light' or 'dark'
                 */
                function setTheme(theme) {
                    document.documentElement.setAttribute("data-theme", theme);
                    localStorage.setItem("theme", theme);

                    // Update button icon based on current theme
                    // Next theme will be the opposite (sun for light mode, moon for dark mode)
                    const iconElement = themeIcon.$.node;
                    if (theme === "dark") {
                        iconElement.className = "fas fa-sun";
                    } else {
                        iconElement.className = "fas fa-moon";
                    }
                }

                /**
                 * Toggles between light and dark themes
                 */
                function toggleTheme() {
                    const currentTheme =
                        document.documentElement.getAttribute("data-theme") ||
                        "light";
                    const newTheme = currentTheme === "dark" ? "light" : "dark";
                    setTheme(newTheme);
                    console.log(`Theme switched to: ${newTheme}`);
                }

                // ===================
                // EVENT HANDLERS - Theme Toggle
                // ===================

                /**
                 * THEME TOGGLE BUTTON
                 * Switches between light and dark themes
                 */
                themeToggleBtn._.on("click", toggleTheme);

                // Initialize blocked button state on load
                updateBlockedButton();

                // Initialize theme on load
                initializeTheme();

                // Initialize chat header state
                updateChatHeader();

                // Initialize chat panel with proper event handler
                // Make sure chat is collapsed initially
                hideChatPanel();
                isChatOpen = false;

                // Check for screen sharing capability and conditionally show/hide button
                if (!navigator.mediaDevices.getDisplayMedia) {
                    // Screen sharing not supported - remove the button
                    shareScreenBtn.$.node.style.display = "none";
                    console.log(
                        "Screen sharing not supported - button removed",
                    );
                } else {
                    console.log("Screen sharing supported");
                }

                // ============================================================
                // EVENT HANDLERS - Profile Settings Modal (DaisyUI Dialog)
                // ============================================================

                /**
                 * UPDATE PROFILE BUTTON
                 * Opens modal to edit display name
                 */
                updateProfileBtn._.on("click", () => {
                    profileModal.$.node.showModal(); // Show modal (DaisyUI dialog method)
                    nameInput.$.node.value = localMetadata.name; // Pre-fill current name
                    avatarInput.$.node.value = localMetadata.avatar_url; // Pre-fill current avatar URL
                });

                // Get modal control elements
                const modalCancel = profileModal.$.node.querySelector(
                    ".btn:not(.btn-success)",
                );

                // Click Cancel to close modal
                modalCancel.addEventListener("click", () => {
                    profileModal.$.node.close(); // Close dialog
                });

                /**
                 * SAVE PROFILE BUTTON
                 * - Updates local metadata with new name and avatar URL
                 * - Uses custom avatar URL if provided, otherwise uses default
                 * - Saves to localStorage
                 * - Updates display
                 */
                saveProfileBtn._.on("click", () => {
                    const newName = nameInput.$.node.value.trim();
                    const newAvatarUrl = avatarInput.$.node.value.trim();

                    if (newName) {
                        localMetadata.name = newName; // Update metadata
                        localStorage.setItem("userName", newName); // Persist name

                        // Update avatar URL - use custom if provided, otherwise default
                        if (newAvatarUrl) {
                            localMetadata.avatar_url = newAvatarUrl;
                        } else {
                            // Generate default random avatar if no custom URL provided
                            localMetadata.avatar_url =
                                "https://osho.is-a.dev/p2p.vc/avatar.png";
                        }
                        localStorage.setItem(
                            "userAvatarUrl",
                            localMetadata.avatar_url,
                        ); // Persist avatar URL

                        // Update UI
                        localAvatar.attrs.src = localMetadata.avatar_url;
                        localName.text = localMetadata.name;
                        profileModal.$.node.close(); // Close dialog

                        console.log(
                            `Profile updated: Name: "${newName}", Avatar: "${localMetadata.avatar_url}"`,
                        );
                    } else {
                        alert("Name is required");
                    }
                });

                // ============================================================
                // EVENT HANDLERS - Chat System
                // ============================================================

                // Chat header event handler handled below with direct DOM access

                // Replace yokto.js event handlers with robust vanilla JavaScript
                setTimeout(() => {
                    // =========================
                    // CHAT HEADER TOGGLE
                    // =========================
                    const chatHeaderElement =
                        document.getElementById("chat-header");
                    if (chatHeaderElement) {
                        chatHeaderElement.addEventListener(
                            "click",
                            function (event) {
                                console.log(
                                    "Chat header clicked!",
                                    event.target,
                                );
                                // Don't toggle if clicking on dropdown or form elements
                                if (
                                    event.target.closest(".dropdown") ||
                                    event.target.tagName === "BUTTON" ||
                                    event.target.closest("form")
                                ) {
                                    return;
                                }
                                toggleChatPanel();
                            },
                        );
                        console.log(
                            "Chat header click handler attached successfully",
                        );
                    } else {
                        console.error("Chat header element not found!");
                    }

                    // =========================
                    // CHAT FORM SUBMIT
                    // =========================
                    const chatFormElement =
                        document.getElementById("chat-form");
                    if (chatFormElement) {
                        chatFormElement.addEventListener(
                            "submit",
                            function (e) {
                                e.preventDefault(); // Prevent form submission
                                const chatInputElement =
                                    document.getElementById("chat-input");
                                const message = chatInputElement.value.trim();
                                console.log(
                                    "Send button clicked, message:",
                                    message,
                                );
                                if (message) {
                                    sendChatMessage(message);
                                }
                            },
                        );
                        console.log(
                            "Chat form submit handler attached successfully",
                        );
                    } else {
                        console.error("Chat form element not found!");
                    }

                    // =========================
                    // CHAT INPUT ENTER KEY
                    // =========================
                    const chatInputElement =
                        document.getElementById("chat-input");
                    if (chatInputElement) {
                        chatInputElement.addEventListener(
                            "keypress",
                            function (e) {
                                if (e.key === "Enter" && !e.shiftKey) {
                                    e.preventDefault(); // Prevent new line
                                    const message =
                                        chatInputElement.value.trim();
                                    console.log(
                                        "Enter pressed, message:",
                                        message,
                                    );
                                    if (message) {
                                        sendChatMessage(message);
                                    }
                                }
                            },
                        );
                        console.log(
                            "Chat input keypress handler attached successfully",
                        );
                    } else {
                        console.error("Chat input element not found!");
                    }

                    // =========================
                    // SEND BUTTON DIRECT CLICK
                    // =========================
                    const sendChatBtnElement =
                        document.getElementById("send-chat-btn");
                    if (sendChatBtnElement) {
                        sendChatBtnElement.addEventListener(
                            "click",
                            function (e) {
                                e.preventDefault();
                                const chatInputElement =
                                    document.getElementById("chat-input");
                                const message = chatInputElement.value.trim();
                                console.log(
                                    "Send button clicked directly, message:",
                                    message,
                                );
                                if (message) {
                                    sendChatMessage(message);
                                }
                            },
                        );
                        console.log(
                            "Send chat button click handler attached successfully",
                        );
                    } else {
                        console.error("Send chat button element not found!");
                    }

                    // =========================
                    // CLEAR CHAT BUTTON - Remove all messages
                    // =========================
                    const clearChatBtnElement =
                        document.getElementById("clear-chat-btn");
                    if (clearChatBtnElement) {
                        clearChatBtnElement.addEventListener(
                            "click",
                            function (e) {
                                e.preventDefault();
                                clearChatMessages();
                            },
                        );
                        console.log(
                            "Clear chat button handler attached successfully",
                        );
                    } else {
                        console.error("Clear chat button element not found!");
                    }
                }, 100); // Small delay to ensure DOM is ready
            });
        </script>
    </body>
</html>
